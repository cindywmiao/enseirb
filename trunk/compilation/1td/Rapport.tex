\documentclass{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{geometry}

%% Si ca ne compile pas chez vous, mettez la ligne suivante en commentaire
%\usepackage{tikz}

%\date{}
\author{Groupe \textsc{Java Bleue} :\\ \\Boucherie Louis\\Gabet Alexandre\\Gardon Henri\\Meunier Bastien (coordinateur)\\Wang Miao }
\title{Compte rendu POO TD7 :\\ Lot trois : Modification de la réalisation}


\begin{document}
\maketitle
\newpage
\section*{1 Gestion d'erreurs et d'instanciation}

\noindent \emph{Dans chaque cas, donner l'état de l'instance fourni par les trois accesseurs et préciser l'incohérence de cet état.}

L'instance retournée par \texttt{JaugeNaturel inverse = new JaugeNaturel(78, 13, 55);} est dans l'état rouge
et bleue simultan\'ement. Il faut interdire la possibilité que la jauge soit de deux couleurs.\\
Dans le second cas, la \texttt{JaugeNaturel} est rouge et ne pourra jamais être verte, il faut aussi interdire ce cas.

\subsection*{1.1 Lever une exception}
\noindent \emph{Expliquer pourquoi dans cette exécution une seule exception est levée et non pas les deux?}

Lorsque deux exceptions sont levées dans la même fonction, celle-ci s'arrête lors de la levée de la première. Elle ne renvoie donc que celle-ci.\\

\noindent \emph{De quelle manière vérifiez-vous que les deux exceptions sont levées ?}

En séparant les deux appels du constructeur de \texttt{JaugeNaturel} dans deux blocs "\texttt{try\{..\} catch\{..\}}" différents, on peut tester séparément si les exceptions se sont déclenchées.
De plus grâce à ces blocs, l’exécution de la fonction n'est pas arrêtée lors du renvoi de la première exception par le constructeur.\\

\noindent \emph{Quelle est la valeur des variables \texttt{inverse} et \texttt{egale} dans la partie \texttt{catch}?}

Ces variables sont indéfinies dans la partie \texttt{catch}. En fait, elles ne sont définies qu'à l'intérieur du bloc \texttt{try\{...\}}.\\

\noindent \emph{Comment déclarer les variables pour les utiliser à la fois dans la clause \texttt{try} et dans la clause \texttt{catch}?}

Il faut séparer la déclaration et l'instanciation des variables. Plus précisément, on déclare les variables avant le bloc \texttt{try\{...\}} de la manière suivante :\\
\texttt{JaugeNaturel egale = null;\\
  JaugeNaturel inverse = null;}\\
Puis on les instancie avec le constructeur de \texttt{JaugeNaturel} dans le bloc \texttt{try\{...\}}.\\

\noindent \emph{Pourquoi le compilateur indique-t-il une erreur si ces variables ne sont pas initialisées?}

Étant donné que nous initialisons nos variables à \texttt{null} avant le bloc \texttt{try} nous n'obtenons pas d'erreur. En effet, dans le cas contraire (seulement déclarée mais initialisée dans le \texttt{try}), le compilateur nous indique que la variable peut ne pas être initialisée, puisque l'exception pourrait être levée pendant ou avant l'initialisation de la variable. 

\section*{2 Paquetage \texttt{tec}}

\emph{Expliquer l’objectif des exceptions contrôlées.}

Les exceptions contrôlées permettent de s'assurer que toutes les erreurs "non fatales" se produisant lors de l'exécution d'un programme soit traitées. Ce qui fait qu'il ne s'arrêtera pas de fonctionner lors d'un dépassement de tableau ou d'une erreur d'instanciation par exemple. \`A la place il exécutera une suite d'instructions permettant de traiter l'erreur.\\

%d'éviter de laisser des erreurs se propager \`a l'exécution. 
%Par exemple, lors d'une erreur d'instanciation, plut\^ot que de laisser une instance mal construite, on ne
%la cr\'ee tout simplement pas et on affiche une erreur \`a la place.

\subsection*{2.1 Exception contrôlée}

\noindent \emph{D’après la description ci-dessus, cette classe doit définir au moins deux constructeurs ; préciser lesquels.}

Comme nous savons que l’instance de \texttt{TecInvalidException} a pour "cause" une erreur lançant une instance de \texttt{IllegalStateException}, il n'est pas n\'ecessaire de faire quatre constructeurs (normalement, il y en a quatre, dont les combinaisons de param\`etres sont "\texttt{String}", "\texttt{String, Throwable}", "\texttt{Throwable}" et aucun param\`etre). Ainsi, les deux constructeurs suivant suffisent :

\begin{verbatim}
  public TecInvalidException(String message){
    super(message, new IllegalStateException());
  }
  
  public TecInvalidException(IllegalStateException e){
    super(e);
  }
\end{verbatim}

\noindent \emph{Pour correspondre à une exception contrôlée de quelle classe ne doit-elle pas hériter ?}

Cette classe ne doit pas hériter de \texttt{java.lang.RuntimeException} ni de ces descendants (tel que \texttt{IllegalStateException}) car ces classes correspondent à des exceptions non contr\^ol\'ees.\\


Pour sp\'ecifier la propagation de l'exception \texttt{TecInvalidException}, on ajoute \texttt{throws TecInvalidException} dans les prototypes des m\'ethodes \texttt{monterDans} et \texttt{allerArretSuivant}.\\


\section*{3 Boutez vos neurones}
\subsection*{3.1 Java Collection Framework}

\noindent \emph{Que représentent les interfaces \texttt{Collection, List, Set, Map?}}

Il s'agit de conteneurs. \texttt{List} et \texttt{Set} sont des implémentations de \texttt{Collection} où \texttt{Collection} représente un ensemble.
Les classes qui les implémentent peuvent contenir différents types d'objets. La principale différence est qu'un \texttt{Set} ne pourra pas contenir plusieurs fois le même élément et que \texttt{List} possède un index.\\
Les implémentations de \texttt{Map} correspondent à différentes implémentation de table de hachages.\\

\noindent \emph{Pourquoi séparer le parcours de la structure de donnée?}

Cela rend la méthode de parcours plus générique. Ainsi on peut par exemple utiliser la même méthode pour deux structures de données différentes sans duplication de code.\\

\noindent \emph{Pourquoi l'itérateur est-il fourni par le conteneur?}

L'itérateur permet de hausser le niveau d'abstraction. C'est à dire que l'on veut n'avoir aucune modification à faire au niveau de l'itérateur si l'on change le conteneur.\\
De plus, l'itérateur doit permettre un parcours optimal quelque soit le conteneur.
Ces deux raisons font qu'il doit être fourni par le conteneur.\\

\noindent \emph{Pourquoi ce framework utilise-t-il le mécanisme de type paramétré ? }

Cela permet de manipuler différents types de passagers ou plus généralement d'objets dans des structures de données sans problème de conversion mais aussi d'obtenir une liste uniforme par rapport au type donné.


\subsection*{3.2 Remaniement de la classe \texttt{Autobus}}
Le remaniement s'est effectué, par exemple dans le cas d'utilisation de la classe \texttt{ArrayList}, de la manière suivante : \\
Tout d'abord on déclare un nouvel attribut dans la classe \texttt{Autobus} : \begin{verbatim}
 private ArrayList<Passager> array_Passagers = new ArrayList<Passager>();
\end{verbatim},
puis lors de la demande de place des passagers (méthode \texttt{demanderPlaceDebout()} ...) on utilise la méthode \texttt{add()}. Par contre lorsqu’il faut rechercher un passager par exemple dans \texttt{demanderSortie()}, on instancie un itérateur \texttt{iter} au sein de la méthode et on parcourt la liste grâce à \texttt{iter.hasNext()} et on compare grâce à \texttt{iter.next() == p} où p est un Passager.\\

\noindent \emph{Dans le code de la classe \texttt{ArrayList}, vérifier de quelle manière est effectuée la suppression d’un élément.}

Pour cette classe, la suppression de manière générale s'effectue en copiant la fin du tableau et en retirant le dernier élément.
La suppression d'un élément peut se faire de trois manières.\\
D'abord la méthode "\texttt{remove(Object o)}" supprime la première itération de l'objet o qu'elle trouve. C'est à dire l'objet o ayant le plus petit indice dans le tableau.\\
La seconde méthode est "\texttt{remove(int index)}" qui enlève l'objet situé à l'indice "index".\\
La dernière méthode est "\texttt{removeRange(int fromIndex, int toIndex)}" qui supprime tout les éléments contenu entre ces deux index.\\

\noindent \emph{Dans le code de la classe LinkedList, vérifier de quelle manière est effectuée la suppression d’un élément.}

Ici la suppression s'effectue en parcourant la liste chaînée, lors de la suppression de l'élément voulu, l'élément précédent est chaîné à l'élément suivant.\\
"\texttt{remove(Object o)}" et "\texttt{remove (int Index)}" s'utilise de la même manière que sur un \texttt{ArrayList}.\\
Il faut ajouter les méthodes \texttt{RemoveFirst(), pollFirst(), RemoveLast()} et \texttt{pollLast()} qui retirent et renvoient le premier et le dernier élément de la liste chaîné. \texttt{remove()} et \texttt{pop()} permettent aussi de supprimer l'élément de tête. De plus, il existe aussi \texttt{removeFirstOccurence(Object o)} et \texttt{removeLastOccurence(Object o)} qui retire respectivement la première et la dernière occurrence de o.\\
Certaines de ces méthodes semblent similaires puisqu'elles suppriment le même élément de la liste mais elles diffèrent par certaines subtilités.

\subsection*{3.2.1  Coordinateur, nous avons un problème !}

\noindent \emph{A l’aide des sources disponibles en ligne, expliquer comment est détecté ce problème dans les classes du framework collection.}

Lors de la modification d'un élément via un itérateur, une exception est levée d\^ue au fait de la séparation du parcours et de la structure. Lors de la modification concurrente de la liste par un itérateur, la méthode \texttt{checkForComodication()} lance l'exception \texttt{ConcurrentModificationException}. 

\subsection*{3.3  Étude de solutions}

\noindent \emph{Montrer que le problème n’est pas résolu même si l’exception n’est plus levée.}\\
La méthode \texttt{get()} n'utilise pas d'itérateurs, elle appartient à la classe \texttt{List} et donc il n'y a pas le problème précédent. Cependant on peut toujours parcourir la liste et la modifier, et obtenir des résultats faussés.\\

\noindent \emph{Donner l’instruction qui permet de copier la collection.}\\
Pour faire une copie de la collection, il faut déclarer une nouvelle collection par exemple \texttt{arrayList2} puis utiliser la méthode \texttt{copy()} de la classe \texttt{Collection} ; par exemple :\\
\texttt{Collections.copy(arrayList2,arrayList1);}\\

\noindent \emph{A l’aide des sources disponibles en ligne, expliquer comment le code de l’itérateur résout le problème de suppression.}\\
Il est nécessaire pour effectuer la suppression de d'abord appeler \texttt{next()} avant d'appeler \texttt{remove()};

\subsection*{3.5  Une classe interne dans la méthode allerArretSuivant()}

\noindent \emph{L’écriture de la classe anonyme est plus simple si la classe anonyme hérite de la classe Autobus. Mais, quel est le danger d’avoir une classe interne qui hérite d’une classe englobante.}\\

Lors de l'appel des méthodes de la classe englobante, la machine ne saura pas si elle doit les appeler sur les instances de la classe englobante ou sur celles de la classe interne. 

\end{document}
